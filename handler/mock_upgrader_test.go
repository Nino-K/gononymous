// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package handler

import (
	"net/http"

	"github.com/Nino-K/gononymous/server"
)

type mockUpgrader struct {
	UpgradeCalled chan bool
	UpgradeInput  struct {
		Arg0 chan http.ResponseWriter
		Arg1 chan *http.Request
		Arg2 chan http.Header
	}
	UpgradeOutput struct {
		Ret0 chan server.Conn
		Ret1 chan error
	}
}

func newMockUpgrader() *mockUpgrader {
	m := &mockUpgrader{}
	m.UpgradeCalled = make(chan bool, 100)
	m.UpgradeInput.Arg0 = make(chan http.ResponseWriter, 100)
	m.UpgradeInput.Arg1 = make(chan *http.Request, 100)
	m.UpgradeInput.Arg2 = make(chan http.Header, 100)
	m.UpgradeOutput.Ret0 = make(chan server.Conn, 100)
	m.UpgradeOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockUpgrader) Upgrade(arg0 http.ResponseWriter, arg1 *http.Request, arg2 http.Header) (server.Conn, error) {
	m.UpgradeCalled <- true
	m.UpgradeInput.Arg0 <- arg0
	m.UpgradeInput.Arg1 <- arg1
	m.UpgradeInput.Arg2 <- arg2
	return <-m.UpgradeOutput.Ret0, <-m.UpgradeOutput.Ret1
}

type mockResponseWriter struct {
	HeaderCalled chan bool
	HeaderOutput struct {
		Ret0 chan http.Header
	}
	WriteCalled chan bool
	WriteInput  struct {
		Arg0 chan []byte
	}
	WriteOutput struct {
		Ret0 chan int
		Ret1 chan error
	}
	WriteHeaderCalled chan bool
	WriteHeaderInput  struct {
		Arg0 chan int
	}
}

func newMockResponseWriter() *mockResponseWriter {
	m := &mockResponseWriter{}
	m.HeaderCalled = make(chan bool, 100)
	m.HeaderOutput.Ret0 = make(chan http.Header, 100)
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.Arg0 = make(chan []byte, 100)
	m.WriteOutput.Ret0 = make(chan int, 100)
	m.WriteOutput.Ret1 = make(chan error, 100)
	m.WriteHeaderCalled = make(chan bool, 100)
	m.WriteHeaderInput.Arg0 = make(chan int, 100)
	return m
}
func (m *mockResponseWriter) Header() http.Header {
	m.HeaderCalled <- true
	return <-m.HeaderOutput.Ret0
}
func (m *mockResponseWriter) Write(arg0 []byte) (int, error) {
	m.WriteCalled <- true
	m.WriteInput.Arg0 <- arg0
	return <-m.WriteOutput.Ret0, <-m.WriteOutput.Ret1
}
func (m *mockResponseWriter) WriteHeader(arg0 int) {
	m.WriteHeaderCalled <- true
	m.WriteHeaderInput.Arg0 <- arg0
}

type mockConn struct {
	ReadMessageCalled chan bool
	ReadMessageOutput struct {
		Ret0 chan int
		Ret1 chan []byte
		Ret2 chan error
	}
	WriteMessageCalled chan bool
	WriteMessageInput  struct {
		Arg0 chan int
		Arg1 chan []byte
	}
	WriteMessageOutput struct {
		Ret0 chan error
	}
}

func newMockConn() *mockConn {
	m := &mockConn{}
	m.ReadMessageCalled = make(chan bool, 100)
	m.ReadMessageOutput.Ret0 = make(chan int, 100)
	m.ReadMessageOutput.Ret1 = make(chan []byte, 100)
	m.ReadMessageOutput.Ret2 = make(chan error, 100)
	m.WriteMessageCalled = make(chan bool, 100)
	m.WriteMessageInput.Arg0 = make(chan int, 100)
	m.WriteMessageInput.Arg1 = make(chan []byte, 100)
	m.WriteMessageOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockConn) ReadMessage() (int, []byte, error) {
	m.ReadMessageCalled <- true
	return <-m.ReadMessageOutput.Ret0, <-m.ReadMessageOutput.Ret1, <-m.ReadMessageOutput.Ret2
}
func (m *mockConn) WriteMessage(arg0 int, arg1 []byte) error {
	m.WriteMessageCalled <- true
	m.WriteMessageInput.Arg0 <- arg0
	m.WriteMessageInput.Arg1 <- arg1
	return <-m.WriteMessageOutput.Ret0
}
